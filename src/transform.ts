/**
 * This module is responsible for transforming an FGA JSON schema (generated by the
 * FGA CLI from a `.fga` file) into a series of inserts into the `authz_model` table
 * in the database.
 *
 * See schemas/v1/example.json for an example JSON output.
 */
import type { schema } from "@arda/db";
import type { FgaSchema } from "./parsing";

/**
 * Transform an FGA schema into a series of inserts into the `authz_model` table.
 *
 * Note, we don't check that any of the relations are valid, outside of very basic
 * checks to ensure we have the data we need. This is because we'll always use the
 * FGA CLI to validate the data before we run this code.
 */
export function generateAuthzModel(
	schemaVersion: number,
	fgaSchema: FgaSchema,
): Result<schema.DbAuthzModelInsert[], Error> {
	const inserts: schema.DbAuthzModelInsert[] = [];

	for (const typeDefinition of fgaSchema.type_definitions) {
		if (!("relations" in typeDefinition)) {
			// If there are no relations on the type (e.g. our 'user' type), then we don't
			// need to insert anything for it.
			continue;
		}

		for (const [relationName, relationDef] of Object.entries(
			typeDefinition.relations,
		)) {
			// Get the subject type from the metadata
			let subjectType: string | null = null;
			if (
				typeDefinition.metadata.relations[relationName]
					?.directly_related_user_types
			) {
				subjectType =
					typeDefinition.metadata.relations[relationName]
						.directly_related_user_types[0].type;
			}

			// If the relation is a `this` type, it means it's standalone and needs exactly
			// the entity_type, relation and subject_type
			if ("this" in relationDef) {
				if (!subjectType) {
					return {
						ok: false,
						error: new Error(
							`Found root level 'this' relationship without a subject type: ${relationName}`,
						),
					};
				}

				inserts.push({
					schema_version: schemaVersion,
					entity_type: typeDefinition.type,
					relation: relationName,
					subject_type: subjectType,
				});
				continue;
			}

			// A computed userset is a relation that inherits from another
			// relation on the same type. It needs entity_type, relation and
			// implied_by
			if ("computedUserset" in relationDef) {
				inserts.push({
					schema_version: schemaVersion,
					entity_type: typeDefinition.type,
					relation: relationName,
					implied_by: relationDef.computedUserset.relation,
				});
				continue;
			}

			// A tupleToUserset is a computed userset based on a relation to a
			// _related_ type. e.g. the 'can_read' relation on a repository is
			// a tupleToUserset of the 'member' relation on the organization
			// defined by the repository's 'organization' relation
			if ("tupleToUserset" in relationDef) {
				inserts.push({
					schema_version: schemaVersion,
					entity_type: typeDefinition.type,
					relation: relationName,
					implied_by: relationDef.tupleToUserset.computedUserset.relation,
					parent_relation: relationDef.tupleToUserset.tupleset.relation,
				});
				continue;
			}

			// A union (as far as we support them) is a relation that requires
			// a direct relationship, like a 'this' relation, but also inherits
			// from another relation, like a 'computedUserset' relation
			if ("union" in relationDef) {
				if (!subjectType) {
					return {
						ok: false,
						error: new Error(
							`Found union relationship without a subject type: ${relationName}`,
						),
					};
				}

				inserts.push({
					schema_version: schemaVersion,
					entity_type: typeDefinition.type,
					relation: relationName,
					subject_type: subjectType,
					implied_by: relationDef.union.child[1].computedUserset.relation,
				});
				continue;
			}

			return {
				ok: false,
				error: new Error(`Unknown relation type: ${relationName}`),
			};
		}
	}

	return { ok: true, data: inserts };
}
