/**
 * This module is responsible for parsing an FGA JSON schema (generated by the
 * FGA CLI from a `.fga` file) into a TypeScipt object.
 *
 * See schemas/v1/example.json for an example JSON output.
 */
import { z } from "zod";

const fgaRelationThisSchema = z.object({ this: z.object({}) });
const fgaRelationComputedUsersetSchema = z.object({
	computedUserset: z.object({
		relation: z.string(),
	}),
});
const fgaRelationsTupleToUsersetSchema = z.object({
	tupleToUserset: z.object({
		tupleset: z.object({ relation: z.string() }),
		computedUserset: z.object({ relation: z.string() }),
	}),
});

// Currently the only union we support is a union of a `this` relation and
// a computed userset
const fgaRelationUnionSchema = z.object({
	union: z.object({
		child: z.tuple([fgaRelationThisSchema, fgaRelationComputedUsersetSchema]),
	}),
});

const fgaRelationSchema = z.union([
	fgaRelationThisSchema,
	fgaRelationComputedUsersetSchema,
	fgaRelationsTupleToUsersetSchema,
	fgaRelationUnionSchema,
]);

/**
 * This does not represent the entirety of what the OpenFGA
 * configuration language is capable of, just the parts we
 * care about. As such, it will fail if any additional features
 * are used.
 */
export const fgaJsonSchema = z.object({
	schema_version: z.literal("1.1"),
	type_definitions: z.array(
		// A type definition may only have a `type` key, but if it
		// has `relations`, then it must also have `metadata`.
		// This is why we use a union here and not optional keys.
		z.union([
			z.object({
				type: z.string(),
				relations: z.record(z.string(), fgaRelationSchema),
				metadata: z.object({
					relations: z.record(
						z.string(),
						z.object({
							// Use a tuple as we only support this being length 1
							directly_related_user_types: z
								.tuple([z.object({ type: z.string() })])
								.optional(),
						}),
					),
				}),
			}),
			z.object({
				type: z.string(),
			}),
		]),
	),
});

export type FgaSchema = z.infer<typeof fgaJsonSchema>;
